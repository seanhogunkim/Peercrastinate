Index: app/src/main/java/com/example/peercrastinationapp/MainActivity.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.peercrastinationapp;\r\n\r\nimport android.app.AppOpsManager;\r\nimport android.app.usage.UsageStats;\r\nimport android.app.usage.UsageStatsManager;\r\nimport android.content.Context;\r\nimport android.content.Intent;\r\nimport android.os.Bundle;\r\nimport android.provider.Settings;\r\nimport android.util.Log;\r\n\r\nimport com.example.peercrastinationapp.ui.entities.Game;\r\n//import com.example.peercrastinationapp.ui.entities.User;\r\nimport com.google.android.material.bottomnavigation.BottomNavigationView;\r\n\r\nimport androidx.appcompat.app.AppCompatActivity;\r\nimport androidx.navigation.NavController;\r\nimport androidx.navigation.Navigation;\r\nimport androidx.navigation.ui.AppBarConfiguration;\r\nimport androidx.navigation.ui.NavigationUI;\r\n\r\nimport com.example.peercrastinationapp.databinding.ActivityMainBinding;\r\n\r\nimport java.util.Calendar;\r\nimport java.util.Date;\r\nimport java.util.Map;\r\nimport java.util.concurrent.ExecutorService;\r\nimport java.util.concurrent.Executors;\r\nimport java.util.concurrent.FutureTask;\r\n\r\nimport io.realm.OrderedCollectionChangeSet;\r\nimport io.realm.OrderedRealmCollectionChangeListener;\r\nimport io.realm.Realm;\r\nimport io.realm.RealmResults;\r\nimport io.realm.mongodb.App;\r\nimport io.realm.mongodb.AppConfiguration;\r\nimport io.realm.mongodb.Credentials;\r\nimport io.realm.mongodb.User;\r\nimport io.realm.mongodb.sync.SyncConfiguration;\r\n\r\npublic class MainActivity extends AppCompatActivity {\r\n\r\n    private ActivityMainBinding binding;\r\n    Realm uiThreadRealm;\r\n    App app;\r\n\r\n    @Override\r\n    protected void onCreate(Bundle savedInstanceState) {\r\n        super.onCreate(savedInstanceState);\r\n\r\n\r\n        binding = ActivityMainBinding.inflate(getLayoutInflater());\r\n        setContentView(binding.getRoot());\r\n\r\n        BottomNavigationView navView = findViewById(R.id.nav_view);\r\n        // Passing each menu ID as a set of Ids because each\r\n        // menu should be considered as top level destinations.\r\n        AppBarConfiguration appBarConfiguration = new AppBarConfiguration.Builder(\r\n                R.id.navigation_home, R.id.navigation_dashboard, R.id.navigation_notifications)\r\n                .build();\r\n        NavController navController = Navigation.findNavController(this, R.id.nav_host_fragment_activity_main);\r\n        NavigationUI.setupActionBarWithNavController(this, navController, appBarConfiguration);\r\n        NavigationUI.setupWithNavController(binding.navView, navController);\r\n      \r\n        AppOpsManager appOps = (AppOpsManager) getSystemService(Context.APP_OPS_SERVICE);\r\n        int mode = appOps.checkOpNoThrow(AppOpsManager.OPSTR_GET_USAGE_STATS,\r\n                android.os.Process.myUid(), getPackageName());\r\n\r\n        if (!(mode == AppOpsManager.MODE_ALLOWED)) {\r\n            startActivityForResult(new Intent(Settings.ACTION_USAGE_ACCESS_SETTINGS), 1);\r\n        }\r\n\r\n        UsageStatsManager usm = (UsageStatsManager) this.getSystemService(Context.USAGE_STATS_SERVICE);\r\n\r\n        Calendar calendar = Calendar.getInstance();\r\n        calendar.add(Calendar.DATE, -7);\r\n        long start = calendar.getTimeInMillis();\r\n        long end = System.currentTimeMillis();\r\n        Map<String, UsageStats> stats = usm.queryAndAggregateUsageStats(start, end);\r\n\r\n        long sum = 0;\r\n        for (Map.Entry<String, UsageStats> i : stats.entrySet()) {\r\n            sum += i.getValue().getTotalTimeInForeground();\r\n        }\r\n\r\n        Log.d(\"myTag\", Long.toString(sum));\r\n\r\n        Realm.init(this); // context, usually an Activity or Application\r\n        String appID = \"peercrastination-kouxz\";\r\n        app = new App(new AppConfiguration.Builder(appID)\r\n                .build());\r\n        Credentials credentials = Credentials.anonymous();\r\n        app.loginAsync(credentials, result -> {\r\n            if (result.isSuccess()) {\r\n                Log.v(\"QUICKSTART\", \"Successfully authenticated anonymously.\");\r\n                User user = app.currentUser();\r\n                String partitionValue = \"leaderboard\";\r\n                SyncConfiguration config = new SyncConfiguration.Builder(\r\n                        user,\r\n                        partitionValue)\r\n                        .build();\r\n                uiThreadRealm = Realm.getInstance(config);\r\n//                addChangeListenerToRealm(uiThreadRealm);\r\n                FutureTask<String> task = new FutureTask(new BackgroundQuickStart(app.currentUser()), \"test\");\r\n                ExecutorService executorService = Executors.newFixedThreadPool(2);\r\n                executorService.execute(task);\r\n            } else {\r\n                Log.e(\"QUICKSTART\", \"Failed to log in. Error: \" + result.getError());\r\n            }\r\n        });\r\n\r\n    }\r\n\r\n    private void addChangeListenerToRealm(Realm realm) {\r\n        // all tasks in the realm\r\n        RealmResults<Leaderboard> tasks = uiThreadRealm.where(Leaderboard.class).findAllAsync();\r\n        tasks.addChangeListener(new OrderedRealmCollectionChangeListener<RealmResults<Leaderboard>>() {\r\n            @Override\r\n            public void onChange(RealmResults<Leaderboard> collection, OrderedCollectionChangeSet changeSet) {\r\n                // process deletions in reverse order if maintaining parallel data structures so indices don't change as you iterate\r\n                OrderedCollectionChangeSet.Range[] deletions = changeSet.getDeletionRanges();\r\n                for (OrderedCollectionChangeSet.Range range : deletions) {\r\n                    Log.v(\"QUICKSTART\", \"Deleted range: \" + range.startIndex + \" to \" + (range.startIndex + range.length - 1));\r\n                }\r\n                OrderedCollectionChangeSet.Range[] insertions = changeSet.getInsertionRanges();\r\n                for (OrderedCollectionChangeSet.Range range : insertions) {\r\n                    Log.v(\"QUICKSTART\", \"Inserted range: \" + range.startIndex + \" to \" + (range.startIndex + range.length - 1));\r\n                }\r\n                OrderedCollectionChangeSet.Range[] modifications = changeSet.getChangeRanges();\r\n                for (OrderedCollectionChangeSet.Range range : modifications) {\r\n                    Log.v(\"QUICKSTART\", \"Updated range: \" + range.startIndex + \" to \" + (range.startIndex + range.length - 1));\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    @Override\r\n    protected void onDestroy() {\r\n        super.onDestroy();\r\n        // the ui thread realm uses asynchronous transactions, so we can only safely close the realm\r\n        // when the activity ends and we can safely assume that those transactions have completed\r\n        uiThreadRealm.close();\r\n        app.currentUser().logOutAsync(result -> {\r\n            if (result.isSuccess()) {\r\n                Log.v(\"QUICKSTART\", \"Successfully logged out.\");\r\n            } else {\r\n                Log.e(\"QUICKSTART\", \"Failed to log out, error: \" + result.getError());\r\n            }\r\n        });\r\n    }\r\n\r\n    public class BackgroundQuickStart implements Runnable {\r\n        User user;\r\n\r\n\r\n        public BackgroundQuickStart(User user) {\r\n            this.user = user;\r\n        }\r\n\r\n        @Override\r\n        public void run() {\r\n            String partitionValue = \"leaderboard\";\r\n            SyncConfiguration config = new SyncConfiguration.Builder(\r\n                    user,\r\n                    partitionValue)\r\n                    .build();\r\n            Realm backgroundThreadRealm = Realm.getInstance(config);\r\n            //https://docs.mongodb.com/realm/sdk/android/quick-start-sync/\r\n            // create entry\r\n            Leaderboard leaderboard = new Leaderboard(\"John\");\r\n            leaderboard.setTime(6);\r\n            // insert entry into database\r\n            backgroundThreadRealm.executeTransaction(transactionRealm -> {\r\n                transactionRealm.insert(leaderboard);\r\n            });\r\n            // update entry\r\n//            backgroundThreadRealm.executeTransaction(transactionRealm -> {\r\n//                Leaderboard otherLeaderboard = transactionRealm.where(Leaderboard.class).equalTo(\"player_id\", \"boomfa\").findFirst();\r\n//                otherLeaderboard.setTime(11.5);\r\n//            });\r\n\r\n            // get all\r\n//            RealmResults<Leaderboard> tables = backgroundThreadRealm.where(Leaderboard.class).findAll();\r\n        }\r\n    }\r\n\r\n\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/example/peercrastinationapp/MainActivity.java b/app/src/main/java/com/example/peercrastinationapp/MainActivity.java
--- a/app/src/main/java/com/example/peercrastinationapp/MainActivity.java	(revision ee0c6a5d1b3c72b0655fa92788efa8ffec12f570)
+++ b/app/src/main/java/com/example/peercrastinationapp/MainActivity.java	(date 1627773509311)
@@ -6,6 +6,7 @@
 import android.content.Context;
 import android.content.Intent;
 import android.os.Bundle;
+import android.os.Process;
 import android.provider.Settings;
 import android.util.Log;
 
@@ -64,7 +65,7 @@
       
         AppOpsManager appOps = (AppOpsManager) getSystemService(Context.APP_OPS_SERVICE);
         int mode = appOps.checkOpNoThrow(AppOpsManager.OPSTR_GET_USAGE_STATS,
-                android.os.Process.myUid(), getPackageName());
+                Process.myUid(), getPackageName());
 
         if (!(mode == AppOpsManager.MODE_ALLOWED)) {
             startActivityForResult(new Intent(Settings.ACTION_USAGE_ACCESS_SETTINGS), 1);
@@ -73,6 +74,7 @@
         UsageStatsManager usm = (UsageStatsManager) this.getSystemService(Context.USAGE_STATS_SERVICE);
 
         Calendar calendar = Calendar.getInstance();
+        //Starts 7 days earlier
         calendar.add(Calendar.DATE, -7);
         long start = calendar.getTimeInMillis();
         long end = System.currentTimeMillis();
@@ -151,8 +153,6 @@
 
     public class BackgroundQuickStart implements Runnable {
         User user;
-
-
         public BackgroundQuickStart(User user) {
             this.user = user;
         }
